{
    "collab_server" : "",
    "contents" : "# contest.R - contrast tests using Satterthwaites df\n\n# contest <- function(L, model, joint=FALSE) {\n#   # Test a contrast L vector/matrix in model\n#   #\n#   # L - vector\n#   # L - matrix (joint = c(TRUE, FALSE))\n#   # L - list of vectors\n#   # L - list of matrices (joint = c(TRUE, FALSE))\n#\n# }\n\n##############################################\n######## contest1D()\n##############################################\n#' Contrast Tests in 1D\n#'\n#' Compute the test of a one-dimensional (vector) contrast in a\n#' linear mixed model fitted with lmer from package \\pkg{lmerTestR}.\n#' The contrast should specify a linear function of the\n#' mean-value parameters, beta. Satterthwaite's method is used to compute the\n#' denominator df for the t-test.\n#'\n#' @param L a numeric (contrast) vector of the same length as\n#' \\code{fixef(model)}.\n#' @param model a model object fitted with \\code{lmer} from package\n#' \\pkg{lmerTestR}, i.e., an object of class \\code{\\link{lmerModLmerTest}}.\n#'\n#' @return A \\code{data.frame} with one row and columns with \\code{\"Estimate\"},\n#' \\code{\"Std. Error\"}, \\code{\"t value\"}, \\code{\"df\"}, and \\code{\"Pr(>|t|)\"}\n#' (p-value)\n#' @export\n#' @seealso \\code{\\link{contestMD}} for multi degree-of-freedom contrast tests.\n#' @author Rune Haubo B. Christensen\n#' @importFrom stats pt\n#'\n#' @examples\n#'\n#' # Fit model using lmer with data from the lme4-package:\n#' fm <- lmer(Reaction ~ Days + (1 + Days|Subject), sleepstudy)\n#' # Note that summary do not contain any tests/p-values:\n#' coef(summary(fm))\n#' # We can get these tests with:\n#' contest1D(c(1, 0), fm) # Test for Intercept\n#' contest1D(c(0, 1), fm) # Test for Days\n#'\ncontest1D <- function(L, model) {\n  if(is.matrix(L)) L <- drop(L)\n  stopifnot(is.numeric(L),\n            length(L) == length(model@parlist$beta))\n  estimate <- sum(L * model@parlist$beta)\n  grad_var_con <-\n    vapply(model@Jac_list, function(x) qform(L, x), numeric(1L)) # = {L' Jac L}_i\n  var_con <- qform(L, model@parlist$vcov_beta)\n  se.estimate <- sqrt(var_con)\n  satt_denom <- qform(grad_var_con, model@A) # g'Ag\n  ddf <- drop(2 * var_con^2 / satt_denom) # denominator DF\n  tstat <- estimate/se.estimate\n  pvalue <- 2 * pt(abs(tstat), df = ddf, lower.tail = FALSE)\n  data.frame(\"Estimate\"=estimate, \"Std. Error\"=se.estimate, \"df\"=ddf,\n             \"t value\"=tstat, \"Pr(>|t|)\"=pvalue, check.names=FALSE)\n}\n\n##############################################\n######## contestMD()\n##############################################\n#' Multiple Degrees-of-Freedom Contrast Tests\n#'\n#' Compute the multi degrees-of-freedom test in a linear mixed model fitted\n#' by \\code{\\link{lmer}}. The contrast (L) specifies a linear function of the\n#' mean-value parameters, beta. Satterthwaite's method is used to compute the\n#' denominator df for the F-test.\n#'\n#' Note: NumDF = row-rank(L) is determined automatically so row rank-deficient L\n#' are allowed. One-dimensional contrasts are also allowed (L has 1 row).\n#'\n#' @param L a contrast matrix with nrow >= 1 and ncol ==\n#' \\code{length(fixef(model))}.\n#' @param model a model object fitted with \\code{lmer} from package\n#' \\pkg{lmerTestR}, i.e., an object of class \\code{\\link{lmerModLmerTest}}.\n#' @param eps tolerance on eigenvalues to determine if an eigenvalue is\n#' positive. The number of positive eigenvalues determine the rank of\n#' L and the numerator df of the F-test.\n#'\n#' @return a \\code{data.frame} with one row and columns with \\code{\"Sum Sq\"},\n#' \\code{\"Mean Sq\"}, \\code{\"F value\"}, \\code{\"NumDF\"} (numerator df),\n#' \\code{\"DenDF\"} (denominator df) and \\code{\"Pr(>F)\"} (p-value).\n#' @export\n#' @seealso \\code{\\link{contest1D}} for tests of 1-dimensional contrasts.\n#' @author Rune Haubo B. Christensen\n#' @importFrom stats pf\n#'\n#' @examples\n#'\n#' fm <- lmer(Reaction ~ Days + I(Days^2) + (1|Subject) + (0+Days|Subject),\n#'            sleepstudy)\n#' # Define 2-df contrast - since L has 2 (linearly independent) rows\n#' # the F-test is on 2 (numerator) df:\n#' L <- rbind(c(0, 1, 0), # Note: ncol(L) == length(fixef(fm))\n#'            c(0, 0, 1))\n#' # Make the 2-df F-test of any effect of Days:\n#' contestMD(L, fm)\n#' # Make the 1-df F-test of the effect of Days^2:\n#' contestMD(L[2, , drop=FALSE], fm)\n#' # Same test, but now as a t-test instead:\n#' contest1D(L[2, , drop=TRUE], fm)\n#'\ncontestMD <- function(L, model, eps=sqrt(.Machine$double.eps)) {\n  mk_Ftable <- function(Fvalue, ndf, ddf, sigma) {\n    MS <- Fvalue * sigma^2\n    pvalue <- pf(q=Fvalue, df1=ndf, df2=ddf, lower.tail=FALSE)\n    data.frame(\"Sum Sq\"=MS*ndf, \"Mean Sq\"=MS, \"NumDF\"=ndf, \"DenDF\"=ddf,\n               \"F value\"=Fvalue, \"Pr(>F)\"=pvalue, check.names = FALSE)\n  }\n  stopifnot(is.matrix(L), is.numeric(L),\n            ncol(L) == length(model@parlist$beta),\n            nrow(L) >= 1)\n  if(nrow(L) == 1) { # 1D case:\n    res <- contest1D(drop(L), model)\n    return(mk_Ftable(Fvalue=res[[\"t value\"]]^2, ndf=1L, ddf=res$df,\n                     sigma=model@parlist$sigma))\n  } # multi-D case proceeds:\n  # Compute Var(L beta) and eigen-decompose:\n  VLbeta <- L %*% model@parlist$vcov_beta %*% t(L) # Var(contrast) = Var(Lbeta)\n  eig_VLbeta <- eigen(VLbeta)\n  tol <- max(eps * eig_VLbeta$values[1], 0)\n  pos <- eig_VLbeta$values > tol\n  q <- sum(pos) # rank(VLbeta)\n  P <- eig_VLbeta$vectors\n  d <- eig_VLbeta$values\n  PtL <- crossprod(P, L)[1:q, ]\n  if(q <= 0) { # shouldn't happen if L is a proper contrast\n    return(mk_Ftable(NA, NA, NA, NA))\n  }\n  if(q == 1) { # 1D case:\n    res <- contest1D(PtL, model)\n    return(mk_Ftable(Fvalue=res[[\"t value\"]]^2, ndf=q, ddf=res$df,\n                     sigma=model@parlist$sigma))\n  } # multi-D case proceeds:\n  # Compute t-squared values and F-value:\n  t2 <- drop(PtL %*% model@parlist$beta)^2 / d[1:q]\n  Fvalue <- sum(t2) / q\n  # Compute q-list of gradients of (PtL)' cov(beta) (PtL) wrt. varpar vector:\n  grad_PLcov <- lapply(1:q, function(m) {\n    vapply(model@Jac_list, function(J) qform(PtL[m, ], J), numeric(1L))\n  })\n  # Compute degrees of freedom for the q t-statistics:\n  nu_m <- vapply(1:q, function(m) {\n    2*(d[m])^2 / qform(grad_PLcov[[m]], model@A) }, numeric(1L)) # 2D_m^2 / g'Ag\n  # Compute ddf for the F-value:\n  ddf <- get_Fstat_ddf(nu_m, tol=1e-8)\n  mk_Ftable(Fvalue, ndf=q, ddf=ddf, sigma=model@parlist$sigma)\n}\n\n##############################################\n######## get_Fstat_ddf()\n##############################################\n#' Compute denominator df for F-test\n#'\n#' From a vector of denominator df from independent t-statistics (\\code{nu}),\n#' the denominator df for the corresponding F-test is computed.\n#'\n#' Note that if any \\code{nu <= 2} then \\code{2} is returned. Also, if all nu\n#' are within tol of each other the simple average of the nu-vector is returned.\n#' This is to avoid downward bias.\n#'\n#' @param nu vector of denominator df for the t-statistics\n#' @param tol tolerance on the consequtive differences between elements of nu to\n#  determine if mean(nu) should be returned\n#'\n#' @author Rune Haubo B. Christensen\n#'\n#' @return the denominator df; a numerical scalar\n#' @keywords internal\nget_Fstat_ddf <- function(nu, tol=1e-8) {\n  # Computes denominator df for an F-statistic that is derived from a sum of\n  # squared t-statistics each with nu_m degrees of freedom.\n  #\n  # nu : vector of denominator df for the t-statistics\n  # tol: tolerance on the consequtive differences between elements of nu to\n  #      determine if mean(nu) should be returned.\n  #\n  # Result: a numeric scalar\n  #\n  # Returns nu if length(nu) == 1. Returns mean(nu) if all(abs(diff(nu)) < tol;\n  # otherwise ddf appears to be downward biased.\n  fun <- function(nu) {\n    if(any(nu <= 2)) 2 else {\n      E <- sum(nu / (nu - 2))\n      2 * E / (E - (length(nu))) # q = length(nu) : number of t-statistics\n    }\n  }\n  stopifnot(length(nu) >= 1,\n            # all(nu > 0), # returns 2 if any(nu < 2)\n            all(sapply(nu, is.numeric)))\n  if(length(nu) == 1L) return(nu)\n  if(all(abs(diff(nu)) < tol)) return(mean(nu))\n  if(!is.list(nu)) fun(nu) else vapply(nu, fun, numeric(1L))\n}\n",
    "created" : 1516047125607.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "251094416",
    "id" : "A5E5AA57",
    "lastKnownWriteTime" : 1516202509,
    "last_content_update" : 1516202509730,
    "path" : "~/Documents/Rpackages/lmerTestR/pkg/R/contest.R",
    "project_path" : "R/contest.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}