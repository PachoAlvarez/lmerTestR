{
    "collab_server" : "",
    "contents" : "##############################################\n######## lmerModLmerTest class\n##############################################\n\n#' Represent Linear Mixed-Effects Models\n#'\n#' The \\code{lmerModLmerTest} class extends \\code{lmerMod} (which extends\n#' \\code{merMod}) from the \\pkg{lme4}-package.\n#'\n#' @slot A a numeric matrix holding the asymptotic variance-covariance matrix\n#' of the variance paramters (including sigma).\n#' @slot Jac_list a list of gradient matrices (Jacobians) for the gradient of\n#' the variance-covariance of beta with respect to the variance parameters,\n#' where beta are the mean-value parameters available in \\code{fixef(object)}.\n#' @slot parlist a list of parameters used internally in \\pkg{lmerTestR} for\n#' computing Satterthwaite's denominator degrees-of-freedom.\n#'\n#' @seealso \\code{\\link[lme4]{lmer}} and \\code{\\link[lme4]{merMod}}\n#' @author Rune Haubo B. Christensen\n#' @importClassesFrom lme4 lmerMod\n#'\n#' @return An object of class \\code{lmerModLmerTest} with slots as in\n#' \\code{lmerMod} objects (see \\code{\\link[lme4]{merMod}}) and a few\n#' additional slots as described in the slots section.\nlmerModLmerTest <-\n  setClass(\"lmerModLmerTest\",\n           contains = c(\"lmerMod\"),\n           representation = representation(A = \"matrix\",\n                                           Jac_list = \"list\",\n                                           parlist = \"list\"))\n\n##############################################\n######## lmer()\n##############################################\n#' Fit Linear Mixed-Effects Models\n#'\n#' This function overloads \\code{\\link[lme4]{lmer}} from the \\pkg{lme4}-package\n#' (\\code{lme4::lmer}) and adds a couple of slots needed for the computation of\n#' Satterthwaite denominator degrees of freedom. All arguments are the same as\n#' for \\code{lme4::lmer} and all the usual \\code{lmer}-methods work.\n#'\n#' For details about \\code{lmer} see \\code{\\link[lme4]{lmer}}\n#' (\\code{help(lme4::lmer)}).\n#'\n#' In cases when a valid \\code{lmer}-object\n#' (\\code{lmerMod}) is produced, but when the computations needed for\n#' Satterthwaite df fails, the \\code{lmerMod} object is returned - not an\n#' \\code{lmerModLmerTest} object.\n#'\n#' @inheritParams lme4::lmer\n#'\n#' @return an S4 object of class \\code{\"lmerModLmerTest\"}\n#' @export\n#' @importFrom lme4 lmerControl\n#' @importFrom methods as new\n#' @seealso \\code{\\link[lme4]{lmer}} and \\code{\\link{lmerModLmerTest}}\n#' @author Rune Haubo B. Christensen\n#'\n#' @examples\n#'\n#' data(\"sleepstudy\", package=\"lme4\")\n#' m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)\n#' class(m)\n#'\nlmer <- function(formula, data = NULL, REML = TRUE,\n                 control = lmerControl(), start = NULL, verbose = 0L,\n                 subset, weights, na.action, offset, contrasts = NULL,\n                 devFunOnly = FALSE, ...) {\n  mc <- match.call()\n  mc[[1]] <- quote(lme4::lmer)\n  model <- eval.parent(mc)\n  if(!inherits(model, \"lmerMod\")) stop(\"A problem occured\")\n  # Make an lmerModLmerTest object:\n  mm <- as(model, \"lmerModLmerTest\")\n  # Assign relevant objects to slots:\n  bm <- boost_lmer(model)\n  mm@parlist <- bm$parlist\n  mm@A <- bm$A\n  mm@Jac_list <- bm$Jac_list\n  return(mm)\n}\n\n##############################################\n######## boost_lmer()\n##############################################\n#' Boost an lmer model-object\n#'\n#' Boosting an lme4::lmer model-object involves computing the covariance\n#' matrix of the variance parameters and the gradient (Jacobian) of cov(beta)\n#' with respect to the variance parameters.\n#'\n#' @param model and lmer model-object -- the result of a call to \\code{lme4::lmer()}\n#' @param tol tolerance for determining of eigenvalues are negative, zero or\n#' positive\n#'\n#' @return a list with components\n#' \\item{parlist}{list of parameter estimates including beta,\n#' theta, sigma (vectors) and vcov(beta) (matrix)}\n#' \\item{A}{the asymptotic covariance matrix of the variance parameters\n#' (theta, sigma)}\n#' \\item{Jac_list}{list of Jacobian matrices; gradients of vcov(beta) with\n#' respect to the variance parameters }\n#'\n#' @importFrom numDeriv hessian jacobian\n#' @importFrom stats vcov update sigma\n#' @importFrom lme4 getME fixef\n#'\n#' @author Rune Haubo B. Christensen\n#'\n#' @examples\n#' m <- lme4::lmer(Reaction ~ Days + (Days | Subject), sleepstudy)\n#' bm <- lmerTestR:::boost_lmer(m)\n#' names(bm)\n#'\n#' @keywords internal\nboost_lmer <- function(model, tol=1e-8) {\n  if(!inherits(model, \"lmerMod\"))\n    stop(\"'model' should be the result of lme4::lmer(), ie., an 'lmerMod'-object\")\n  # if(!require(numDeriv)) stop(\"package numDeriv is required\")\n  # res <- list(model=model)\n  res <- list()\n  res$parlist <- list(beta=fixef(model),\n                      theta=getME(model, \"theta\"),\n                      sigma=sigma(model),\n                      vcov_beta = as.matrix(vcov(model)))\n  devfun <- update(model, devFunOnly=TRUE)\n  is_reml <- getME(model, \"is_REML\")\n  varpar_opt <- unname(c(res$parlist$theta, res$parlist$sigma))\n  # Compute Hessian:\n  h <- numDeriv::hessian(func=devfun_vp, x=varpar_opt, devfun=devfun, reml=is_reml)\n  # Eigen decompose the Hessian:\n  eig_h <- eigen(h, symmetric=TRUE)\n  if(any(eig_h$values < -tol))\n    stop(\"Model did not converge: Hessian has negative eigenvalues\")\n  if(any(abs(eig_h$values) < tol))\n    warning(\"Hessian is singular: model may not have converged\")\n  # Compute vcov(varpar):\n  h_inv <- with(eig_h, vectors %*% diag(1/values) %*% t(vectors))\n  res$A <- 2 * h_inv\n  # Compute Jacobian of cov(beta) for each varpar and save in list:\n  Jac <- jacobian(func=get_covbeta, x=varpar_opt, devfun=devfun)\n  res$Jac_list <- lapply(1:ncol(Jac), function(i)\n    array(Jac[, i], dim=rep(length(res$parlist$beta), 2))) # k-list of jacobian matrices\n  # class(res) <- \"boostler\"\n  res\n}\n\n##############################################\n######## devfun_vp()\n##############################################\n#' Compute deviance of an LMM as a function of variance parameters\n#'\n#' This function is used for extracting the asymptotic variance-covariance matrix\n#'   of the variance parameters.\n#'\n#' @param varpar variance parameters; \\code{varpar = c(theta, sigma)}.\n#' @param devfun deviance function as a function of theta only.\n#' @param reml if \\code{TRUE} the REML deviance is computed;\n#'   if \\code{FALSE}, the ML deviance is computed.\n#'\n#' @return the REML or ML deviance.\n#' @author Rune Haubo B. Christensen\n#' @keywords internal\ndevfun_vp <- function(varpar, devfun, reml) {\n  nvarpar <- length(varpar)\n  sigma2 <- varpar[nvarpar]^2\n  theta <- varpar[-nvarpar]\n  df_envir <- environment(devfun)\n  devfun(theta) # Evaluate deviance function at varpar\n  n <- nrow(df_envir$pp$V)\n  # Compute deviance for ML:\n  dev <- df_envir$pp$ldL2() + (df_envir$resp$wrss() + df_envir$pp$sqrL(1))/sigma2 +\n    n * log(2 * pi * sigma2)\n  if(!reml) return(dev)\n  # Adjust of REML is used:\n  RX <- df_envir$pp$RX() # X'V^{-1}X ~ crossprod(RX^{-1}) = cov(beta)^{-1} / sigma^2\n  dev + 2*c(determinant(RX)$modulus) - ncol(RX) * log(2 * pi * sigma2)\n}\n\n##############################################\n######## get_covbeta()\n##############################################\n#' Compute cov(beta) as a function of varpar of an LMM\n#'\n#' At the optimum cov(beta) is available as vcov(lmer-model). This function\n#' computes cov(beta) at non (RE)ML estimates of \\code{varpar}.\n#'\n#' @inheritParams devfun_vp\n#'\n#' @return cov(beta) at supplied varpar values.\n#' @author Rune Haubo B. Christensen\n#' @keywords internal\nget_covbeta <- function(varpar, devfun) {\n  nvarpar <- length(varpar)\n  sigma <- varpar[nvarpar] # residual std.dev.\n  theta <- varpar[-nvarpar] # ranef var-par\n  devfun(theta) # evaluate REML or ML deviance 'criterion'\n  df_envir <- environment(devfun) # extract model environment\n  sigma^2 * tcrossprod(df_envir$pp$RXi()) # vcov(beta)\n}\n",
    "created" : 1516090055133.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "27511359",
    "id" : "5EA4C1ED",
    "lastKnownWriteTime" : 1516201944,
    "last_content_update" : 1516201944554,
    "path" : "~/Documents/Rpackages/lmerTestR/pkg/R/lmer.R",
    "project_path" : "R/lmer.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}